"""
Copyright (C) 2021 Mayank Vats
See license.txt
/* Copyright (C) Mayank Vats - All Rights Reserved
* Unauthorized copying of any file, via any medium is strictly prohibited
* Proprietary and confidential
* Contact the author if you want to use it.
* Feel free to use the static and template files
* Written by Mayank Vats <testpass.py@gmail.com>, 2021
*/
If you have this file and weren't given access to it by
the author, you're breaching copyright, delete this file
immediately and contact the author on the aforementioned
email address. Don't worry, you should be fine as long as you don't
use or distribute this software.
"""
from flask import Blueprint, render_template, request, flash, redirect, url_for, session
from flask_login import login_user, login_required, logout_user, current_user
from werkzeug.exceptions import abort
from website import db
from datetime import datetime
from website.models import User, Post, Comment
from website.tert import OTPMethods, ElectronicMail
from AuthAlpha.Password_Hashing import PassHashing

# creating an instance of blueprint class for auth.py, later to be registered in the app.
auth = Blueprint('auth', __name__)

rn_jesus = OTPMethods()
postman = ElectronicMail()
password_police = PassHashing("argon2id")
otp_police = PassHashing("pbkdf2:sha256")


"""
i)Referrer:
Using request.referrer we are able to restrict user access to certain webpages (like OTP check pages).
We create a list, namely 'auth_ref' with acceptable paths or 'referrals' to these webpages, only through
these paths, the user can access these urls. Otherwise a 403 error is raised.

ii)user=current_user:
This is returned with the template rendered for a specific view for views that don't explicitly use it.
This is on purpose, as we use it to Dynamically display user data (if user is not None) and is used to
manage the display of certain features. Eg: Users with admin role don't have an option to delete account,
it has to be done manually from database terminal (for security purposes).

iii)Decorators:
-> @auth.route : Used to define routes and accepted method for views in auth.py
-> @login_required : Use to restrict access to certain views. These views are accessible only when the user
is authenticated.
"""


@auth.route('/', methods=['GET'])
def home():
    """
    The landing page, http://127.0.0.1:5000/
    :return: renders template index.html
    """
    return render_template("index.html", user=current_user)


@auth.route('/create', methods=['GET', 'POST'])
def create():
    """
    Initiates the account creation process, assigns value to Global Variables:
    1. EMAIL (Otherwise None),
    2. COMP_OTP (OTP generated by the computer, see class OTPMethods in tert.py),
    3. PASSWORD (Private, un-hashed password inputted by user)
    These variable are defined at module level so as to keep information consistent.
    These variables are initially initialized as None. These variables ensure that at one-time
    for one one user, variables remain constant.
    If request method is 'POST', the aforementioned variables are filled with
    appropriate values, after that using the instance of SQLALchemy() (db), we
    check if the user(email id -> primary unique key) already exists. If the checks
    are passed, comp_otp is generated and emailed (see sendmail() in tert.py for more info)
    and the user is redirected to auth.otp.
    P.S you don't need to worry about regex as it has already been implemented in the
    create.html file.

    :return: renders template create.html
    """

    if request.method == 'POST':
        session['NAME'] = request.form['name']
        session['EMAIL'] = request.form['email']
        session['PASSWORD'] = password_police.generate_password_hash(request.form['pass'])
        exists = db.session.query(User.id).filter_by(email=session['EMAIL']).first() is not None
        if exists == 0:
            return redirect(url_for('auth.otp'))
        else:
            del session['PASSWORD']
            flash('email already in use!!', category='error')

    return render_template("create.html", user=current_user)


@auth.route('/otp', methods=['GET', 'POST'])
def otp():
    """
    Used to perform OTP checks specifically for account creation
    (i.e for email verification). It creates a global variable, user_otp which will
    later be used to store otp entered by the user. If the user enters the correct OTP,
    a new instance of User class is created, fields are mentioned in models.py file.
    Password is hashed using generate_password_hash function in werkzeug.security.
    Hashing algorithm used is pbkdf2 (101000 rounds), default role (see User class
    in models.py) is 'user'. It can be later changed by a user with admin privileges.
    Successful navigation through this view creates an account and logs in the user
    (Using the login_manager configured in __init__UP.py line 96),
    redirecting them to auth.success. By default, 'Remember me functionality', is
    disabled. You can turn it on by changing 'remember = True'.
    NOTE: Turning on 'Remember me' breaks the session time-out functionality.
    (see __init__UP.py line 29)

    :return: renders template otp.html
    """
    referrer = request.referrer
    auth_href = [
        "/create",
        "/otp"
    ]
    if referrer:
        if referrer[21:] in auth_href:
            if request.method == 'GET':
                COMP_OTP = rn_jesus.return_random(otp_len=6)
                postman.sendmail(session['EMAIL'], "Citadel Log-in Authorization", COMP_OTP)
                session['COMP_OTP'] = otp_police.generate_password_hash(COMP_OTP, cost=50000)
            if request.method == 'POST':
                session['USER_OTP'] = request.form['otp']
                if otp_police.check_password_hash(session['COMP_OTP'], session['USER_OTP']):
                    del session['USER_OTP']
                    del session['COMP_OTP']
                    new_user = User(name=session['NAME'],
                                    password=session['PASSWORD'],
                                    email=session['EMAIL'],
                                    active=True,
                                    last_confirmed_at=datetime.now())
                    del session['PASSWORD']
                    db.session.add(new_user)
                    db.session.commit()
                    login_user(new_user, remember=False)
                    session.permanent = True
                    return redirect(url_for('auth.success'))

                else:
                    flash('Wrong otp', category='error')
        else:
            abort(403)
    else:
        abort(403)
    return render_template("otp.html", user=current_user)


@auth.route('/login', methods=['GET', 'POST'])
def login():
    """
    The Login page, registered at __init__UP.py line 99.
    Defines variables:
    1. Lemail : (Login Email)
    2. LFA_otp : (OTP generated by by the computer, see OTP() function in tert.py,
    Only generated if user has 2FA functionality enabled)
    3. p_pass : (private, un-hashed password inputted by user)
    4. user : An instance of User class (See models.py). Used to check the existence
    of Lemail, i.e the user.
    globally, so as to keep information consistent.
    Now, the user inputted password
    is hashed against the previously stored salt which is the checked against the already stored
    stored password.
    When user.2FA (A boolean which stores the status of 2FA) is
    i)  False: The user is logged in with the aforementioned protocols(see create() and otp())
    ii) True: Now, LFA_otp is initialized and user is redirected to auth.FAlogin (see line 177)

    :return: renders template login.html
    """
    if request.method == 'POST':
        session['EMAIL'] = request.form['email']
        PASSWORD = request.form['pass']
        user = User.query.filter_by(email=session['EMAIL']).first()
        if user:
            if not user.two_FA:
                if password_police.check_password_hash(user.password, PASSWORD):
                    login_user(user, remember=False)
                    user.active = True
                    user.last_confirmed_at = datetime.now()
                    db.session.commit()
                    session.permanent = True
                    return redirect(url_for('auth.home'))
                else:
                    flash('Incorrect password, try again.', category='error')
            else:
                if password_police.check_password_hash(user.password, PASSWORD):
                    return redirect(url_for('auth.mfalogin'))
                else:
                    flash('Incorrect password, try again.', category='error')
        else:
            flash('Email does not exist.', category='error')

    return render_template("login.html", user=current_user)


@auth.route('/FAlogin', methods=['GET', 'POST'])
def mfalogin():
    """
    This view is only accessible through '/login' and associated referrals, the previously
    initialized LFA_otp is now mailed to the user trying to log-in, Now if the user
    correctly POSTS the otp mailed to them, they're logged in with the aforementioned protocols
    (see create() and otp()).

    :return: renders template FAlogin.html
    """
    referrer = request.referrer
    auth_href = [
        "/login",
        "/login?next=%2Flogout",
        "/login?next=%2Faddblog",
        "/login?next=%2Flogout",
        "/login?next=%2Fsecrets",
        "/login?next=%2Ftwo_FA",
        "/login?next=%2Fsuccess",
        "/login?next=%2Fdisable2FA",
        "/login?next=%2Fdelete",
        "/FAlogin"
    ]
    if referrer:
        if referrer[21:] in auth_href:
            if request.method == 'GET':
                COMP_OTP = rn_jesus.return_random(otp_len=6)
                postman.sendmail(session['EMAIL'], "Citadel Log-in Authorization", COMP_OTP)
                session['COMP_OTP'] = otp_police.generate_password_hash(COMP_OTP, cost=50000)
            if request.method == 'POST':
                session['USER_OTP'] = request.form['Lotp']
                if otp_police.check_password_hash(session['COMP_OTP'], session['USER_OTP']):
                    del session['USER_OTP']
                    del session['COMP_OTP']
                    user = User.query.filter_by(email=session['EMAIL']).first()
                    login_user(user, remember=False)
                    user.active = True
                    user.last_confirmed_at = datetime.now()
                    db.session.commit()
                    session.permanent = True
                    return redirect(url_for('auth.home'))
                else:
                    flash('Wrong otp', category='error')
        else:
            abort(403)
    else:
        abort(403)
    return render_template("FAlogin.html", email=session['EMAIL'])


@auth.route('/logout')
@login_required
def logout():
    """
    Self explanatory view, logs-out (terminates session) of a user already logged-in.
    Will be automatically called after session times-out after 12 hours (see __init__UP.py line 29)

    :return: redirects to auth.login
    """
    user = User.query.filter_by(email=current_user.email).first()
    user.active = False
    db.session.commit()
    for key in list(session.keys()):
        session.pop(key)
    logout_user()
    return redirect(url_for('auth.login'))


@auth.route('/secrets', methods=['GET', 'POST'])
@login_required
def secrets():
    """
    Account overview page, gateway to enable 2FA, that is why twoFA_otp
    is globally initialized.

    :return: renders template secrets.html
    """
    return render_template("secrets.html", user=current_user)


@auth.route('/about', methods=['GET', 'POST'])
def about():
    """
    About page, TO BE UPDATED

    :return: renders template about.html
    """
    return render_template("about.html", user=current_user)


@auth.route('/two_FA', methods=['GET', 'POST'])
@login_required
def two_fa():
    """
    Only referable from /secrets, on being called, emails two_FA_otp to the current user,
    If the user POSTS the correct OTP, Two Factor Authentication is enabled on their account,
    now, they would have to enter an emailed otp to log-in. Can be disabled on the Account
    Overview page.

    :return: renders template two_FA.html
    """
    referrer = request.referrer
    auth_href = [
        "/secrets",
        "/two_FA"
    ]
    if referrer:
        if referrer[21:] in auth_href:
            if request.method == 'GET':
                COMP_OTP = rn_jesus.return_random(otp_len=6)
                postman.sendmail(session['EMAIL'], "Citadel Log-in Authorization", COMP_OTP)
                session['COMP_OTP'] = otp_police.generate_password_hash(COMP_OTP, cost=50000)
            if request.method == 'POST':
                session['USER_OTP'] = request.form['two_otp']
                if otp_police.check_password_hash(session['COMP_OTP'], session['USER_OTP']):
                    del session['USER_OTP']
                    del session['COMP_OTP']
                    user = User.query.filter_by(email=current_user.email).first()
                    user.two_FA = True
                    db.session.commit()
                    flash('2FA enabled', category='success')
                    logout()
                    return redirect(url_for('auth.login'))
                else:
                    flash('Wrong otp', category='error')
        else:
            abort(403)
    else:
        abort(403)
    return render_template("two_FA.html", user=current_user)


@auth.route('/success')
@login_required
def success():
    """
    The page where the user is redirected on successful creation of account.

    :return: renders template success.html
    """
    return render_template("success.html", user=current_user)


@auth.route('/disable2FA')
@login_required
def disable2fa():
    """
    View globally accessible after logging in, used to disable
    two factor authentication.

    :return: renders template disable2FA.html
    """
    user = User.query.filter_by(email=current_user.email).first()
    user.two_FA = False
    db.session.commit()
    flash('2FA disabled', category='error')
    logout()
    return redirect(url_for('auth.login'))


@auth.route('/femail', methods=['GET', 'POST'])
def femail():
    """
    FORGOT PASSWORD FUNCTIONALITY:
    It is implemented using the following three Views:
    I] femail (forgot-email): Here the user has to enter their registered email address.
    This view is only accessible through /login and associated pages. If this page is
    called, an OTP is generated i.e FOTP. Now, if the user posts a valid email address,
    They are redirected to /OTPcheck (line 377).

    :return: renders template femail.html
    """
    referrer = request.referrer
    auth_href = [
        "/login",
        "/login?next=%2Flogout",
        "/login?next=%2Faddblog",
        "/login?next=%2Flogout",
        "/login?next=%2Fsecrets",
        "/login?next=%2Ftwo_FA",
        "/login?next=%2Fsuccess",
        "/login?next=%2Fdisable2FA",
        "/login?next=%2Fdelete",
        "/secrets",
        "/femail"
    ]
    if referrer:
        if referrer[21:] in auth_href:
            if request.method == 'POST':
                session['EMAIL'] = request.form['Remail']
                user = User.query.filter_by(email=session['EMAIL']).first()
                if user:
                    return redirect(url_for('auth.otp_check'))
                else:
                    flash("No such user exists!", category='error')
        else:
            abort(403)
    else:
        abort(403)
    return render_template("femail.html")


@auth.route('/OTPCheck', methods=['GET', 'POST'])
def otp_check():
    """
    II] OTPCheck: Referable only from /femail. When this page is called, an OTP
    is emailed to the previously entered email address, now, If the user POSTS
    the correct OTP, they are redirected to /passreset (line 410), where they will be allowed
    to reset their password.

    :return: renders template OTPCheck.html
    """
    referrer = request.referrer
    auth_href = [
        "/femail",
        "/OTPCheck"
    ]
    if referrer:
        if referrer[21:] in auth_href:
            if request.method == 'GET':
                COMP_OTP = rn_jesus.return_random(otp_len=6)
                postman.sendmail(session['EMAIL'], "Citadel Log-in Authorization", COMP_OTP)
                session['COMP_OTP'] = otp_police.generate_password_hash(COMP_OTP, cost=50000)
            if request.method == 'POST':
                session['USER_OTP'] = request.form['otp']
                if otp_police.check_password_hash(session['COMP_OTP'], session['USER_OTP']):
                    del session['USER_OTP']
                    del session['COMP_OTP']
                    return redirect(url_for('auth.passreset'))
                else:
                    flash('Wrong otp', category='error')
        else:
            abort(403)
    else:
        abort(403)
    return render_template("OTPCheck.html")


@auth.route('/passreset', methods=['GET', 'POST'])
def passreset():
    """
    III] passreset: Referable only from /OTPCheck. Here the user POSTS a new password,
    if the user role wasn't admin, their account is updated normally, accounts with admin
    roles will updated but with role method overridden. After the updating, the user is
    logged in with the aforementioned protocols (see create() and otp()).

    :return: renders template passreset.html
    """
    referrer = request.referrer
    auth_href = [
        "/OTPCheck",
        "/passreset"
    ]
    if referrer:
        if referrer[21:] in auth_href:
            if request.method == 'POST':
                session['PASSWORD'] = password_police.generate_password_hash(request.form['pass'])
                check_password = request.form['cpass']
                if password_police.check_password_hash(session['PASSWORD'], check_password):
                    user = User.query.filter_by(email=session['EMAIL']).first()
                    user.password = session['PASSWORD']
                    del session['PASSWORD']
                    db.session.commit()
                    flash('Password changed successfully!', category='success')
                    return redirect(url_for('auth.home'))
                else:
                    del session['PASSWORD']
                    flash("The passwords don't match", category='error')
        else:
            abort(403)
    else:
        abort(403)

    return render_template("passreset.html", user=current_user)


@auth.route('/delete', methods=['GET', 'POST'])
@login_required
def delete():
    """
    Self explanatory view, deletes the account, all the posts and the comments made by the user.
    Users with admin role don't have an option to their delete account,
    it has to be done manually from database terminal (for security purposes).

    :return: renders template delete.html
    """
    if request.method == 'POST' and current_user.role != "admin":
        session['EMAIL'] = current_user.email
        Post.query.filter_by(user_id=current_user.id).delete()
        Comment.query.filter_by(user_id=current_user.id).delete()
        User.query.filter_by(email=current_user.email).delete()
        db.session.commit()
        logout_user()
        for key in list(session.keys()):
            session.pop(key)
        return redirect(url_for('auth.home'))
    return render_template('delete.html', user=current_user)
