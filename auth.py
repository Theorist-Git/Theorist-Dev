"""
Copyright (C) 2021 Mayank Vats
See license.txt
"""
from flask import Blueprint, render_template, request, flash, redirect, url_for, session
from flask_login import login_user, login_required, logout_user, current_user
from werkzeug.exceptions import abort
from website import db
from datetime import datetime
from website.models import User, Post, Comment
from website import tert

# creating an instance of blueprint class for auth.py, later to be registered in the app.
auth = Blueprint('auth', __name__)

rn_jesus = tert.OTPMethods
postman = tert.ElectronicMail
password_police = tert.CryptographyMethods.Hashing


"""
i)Referrer:
Using request.refferer we are able to restrict user access to certain webpages (like OTP check pages).
We create a list, namely 'auth_ref' with acceptable paths or 'referrals' to these webpages, only through
these paths, the user can access these urls. Otherwise a 403 error is raised.

ii)user=current_user:
This is returned with the template rendered for a specific view for views that don't explicitly use it.
This is on purpose, as we use it to Dynamically display user data (if user is not None) and is used to
manage the display of certain features. Eg: Users with admin role don't have an option to delete account,
it has to be done manually from database terminal (for security purposes).

iii)Decorators:
-> @auth.route : Used to define routes and accepted method for views in auth.py
-> @login_required : Use to restrict access to certain views. These views are accessible only when the user
is authenticated.
"""


@auth.route('/', methods=['GET'])
def home():
    """
    The landing page, http://127.0.0.1:5000/
    :return: renders template index.html
    """
    return render_template("index.html", user=current_user)


@auth.route('/create', methods=['GET', 'POST'])
def create():
    """
    Initiates the account creation process, defines variables: email,
    comp_otp(OTP generated by the computer, see OTP() function in tert.py),
    p_pass(private, un-hashed password inputted by user) globally, so as to keep
    information consistent. These variables are initially initialized as None.
    If request method is 'POST', the aforementioned variables are filled with
    appropriate values, after that using the instance of SQLALchemy() (db), we
    check if the user(email id -> primary unique key) already exists. If the checks
    are passed, comp_otp is generated and emailed (see sendmail() in tert.py for more info)
    and the user is redirected to auth.otp.
    P.S you don't need to worry about regex as it has already been implemented in the
    create.html file.

    :return: renders template create.html
    """
    global email, comp_otp, p_pass, name
    email = None
    comp_otp = None
    p_pass = None
    name = None
    if request.method == 'POST':
        name = request.form['name']
        email = request.form['email']
        p_pass = request.form['pass']
        exists = db.session.query(User.id).filter_by(email=email).first() is not None
        if exists == 0:
            comp_otp = rn_jesus.return_random(otp_len=6)
            postman.sendmail(email, "Citadel Log-in Authorization", comp_otp)
            return redirect(url_for('auth.otp'))
        else:
            flash('email already in use!!', category='error')

    return render_template("create.html", user=current_user)


@auth.route('/otp', methods=['GET', 'POST'])
def otp():
    """
    Used to perform OTP checks specifically for account creation
    (i.e for email verification). It creates a global variable, user_otp which will
    later be used to store otp entered by the user. If the user enters the correct OTP,
    a new instance of User class is created, fields are mentioned in models.py file.
    Password is hashed using generate_password_hash function in werkzeug.security.
    Hashing algorithm used is pbkdf2 (101000 rounds), default role (see User class
    in models.py) is 'user'. It can be later changed by a user with admin privileges.
    Successful navigation through this view creates an account and logs in the user
    (Using the login_manager configured in __init__UP.py line 96),
    redirecting them to auth.success. By default, 'Remember me functionality', is
    disabled. You can turn it on by changing 'remember = True'.
    NOTE: Turning on 'Remember me' breaks the session time-out functionality.
    (see __init__UP.py line 29)

    :return: renders template otp.html
    """
    global user_otp
    referrer = request.referrer
    auth_href = [
        "/create",
        "/otp"
    ]
    if referrer:
        if referrer[21:] in auth_href:
            if request.method == 'POST':
                user_otp = request.form['otp']
                if user_otp == comp_otp:

                    new_user = User(name=name,
                                    password=password_police.generate_password_hash(p_pass, method='argon2id'),
                                    email=email,
                                    active=True,
                                    last_confirmed_at=datetime.now())
                    db.session.add(new_user)
                    db.session.commit()
                    login_user(new_user, remember=False)
                    session.permanent = True
                    user_otp = None
                    return redirect(url_for('auth.success'))

                else:
                    flash('Wrong otp', category='error')
        else:
            abort(403)
    else:
        abort(403)
    return render_template("otp.html", user=current_user)


@auth.route('/login', methods=['GET', 'POST'])
def login():
    """
    The Login page, registered at __init__UP.py line 99.
    Defines variables:
    1. Lemail : (Login Email)
    2. LFA_otp : (OTP generated by by the computer, see OTP() function in tert.py,
    Only generated if user has 2FA functionality enabled)
    3. p_pass : (private, un-hashed password inputted by user)
    4. user : An instance of User class (See models.py). Used to check the existence
    of Lemail, i.e the user.
    globally, so as to keep information consistent.
    Now, the user inputted password
    is hashed against the previously stored salt which is the checked against the already stored
    stored password.
    When user.2FA (A boolean which stores the status of 2FA) is
    i)  False: The user is logged in with the aforementioned protocols(see create() and otp())
    ii) True: Now, LFA_otp is initialized and user is redirected to auth.FAlogin (see line 177)

    :return: renders template login.html
    """
    global Lemail, LFA_otp, p_pass, user
    if request.method == 'POST':
        Lemail = request.form['email']
        p_pass = request.form['pass']
        user = User.query.filter_by(email=Lemail).first()
        if user:
            if not user.two_FA:
                if password_police.check_password_hash(user.password, p_pass):
                    login_user(user, remember=False)
                    user.active = True
                    user.last_confirmed_at = datetime.now()
                    db.session.commit()
                    session.permanent = True
                    return redirect(url_for('auth.home'))
                else:
                    flash('Incorrect password, try again.', category='error')
            else:
                if password_police.check_password_hash(user.password, p_pass):
                    LFA_otp = rn_jesus.return_random(otp_len=6)
                    return redirect(url_for('auth.FAlogin'))
                else:
                    flash('Incorrect password, try again.', category='error')
        else:
            flash('Email does not exist.', category='error')

    return render_template("login.html", user=current_user)


@auth.route('/FAlogin', methods=['GET', 'POST'])
def FAlogin():
    """
    This view is only accessible through '/login' and associated referrals, the previously
    initialized LFA_otp is now mailed to the user trying to log-in, Now if the user
    correctly POSTS the otp mailed to them, they're logged in with the aforementioned protocols
    (see create() and otp()).

    :return: renders template FAlogin.html
    """
    referrer = request.referrer
    auth_href = [
        "/login",
        "/login?next=%2Flogout",
        "/login?next=%2Faddblog",
        "/login?next=%2Flogout",
        "/login?next=%2Fsecrets",
        "/login?next=%2Ftwo_FA",
        "/login?next=%2Fsuccess",
        "/login?next=%2Fdisable2FA",
        "/login?next=%2Fdelete",
        "/FAlogin"
    ]
    if referrer:
        if referrer[21:] in auth_href:
            if request.method == 'GET':
                postman.sendmail(Lemail, "Citadel Log-in Authorization", LFA_otp)
            if request.method == 'POST':
                Fuser_otp = request.form['Lotp']
                if Fuser_otp == LFA_otp:
                    user = User.query.filter_by(email=Lemail).first()
                    login_user(user, remember=False)
                    user.active = True
                    user.last_confirmed_at = datetime.now()
                    db.session.commit()
                    session.permanent = True
                    Fuser_otp = None
                    return redirect(url_for('auth.home'))
                else:
                    flash('Wrong otp', category='error')
        else:
            abort(403)
    else:
        abort(403)
    return render_template("FAlogin.html", user=current_user)


@auth.route('/logout')
@login_required
def logout():
    """
    Self explanatory view, logs-out (terminates session) of a user already logged-in.
    Will be automatically called after session times-out after 12 hours (see __init__UP.py line 29)

    :return: redirects to auth.login
    """
    user = User.query.filter_by(email=current_user.email).first()
    user.active = False
    db.session.commit()
    logout_user()
    return redirect(url_for('auth.login'))


@auth.route('/secrets', methods=['GET', 'POST'])
@login_required
def secrets():
    """
    Account overview page, gateway to enable 2FA, that is why twoFA_otp
    is globally initialized.

    :return: renders template secrets.html
    """
    global twoFA_otp
    twoFA_otp = rn_jesus.return_random(otp_len=6)
    return render_template("secrets.html", user=current_user)


@auth.route('/about', methods=['GET', 'POST'])
def about():
    """
    About page, TO BE UPDATED

    :return: renders template about.html
    """
    return render_template("about.html", user=current_user)


@auth.route('/two_FA', methods=['GET', 'POST'])
@login_required
def two_FA():
    """
    Only referable from /secrets, on being called, emails two_FA_otp to the current user,
    If the user POSTS the correct OTP, Two Factor Authentication is enabled on their account,
    now, they would have to enter an emailed otp to log-in. Can be disabled on the Account
    Overview page.

    :return: renders template two_FA.html
    """
    referrer = request.referrer
    auth_href = [
        "/secrets",
        "/two_FA"
    ]
    if referrer:
        if referrer[21:] in auth_href:
            if request.method == 'GET':
                postman.sendmail(current_user.email, "Citadel Log-in Authorization", twoFA_otp)
            if request.method == 'POST':
                two_user_otp = request.form['two_otp']
                if two_user_otp == twoFA_otp:
                    admin = User.query.filter_by(email=current_user.email).first()
                    admin.two_FA = True
                    db.session.commit()
                    flash('2FA enabled', category='success')
                    logout()
                    return redirect(url_for('auth.login'))
                else:
                    flash('Wrong otp', category='error')
        else:
            abort(403)
    else:
        abort(403)
    return render_template("two_FA.html", user=current_user)


@auth.route('/success')
@login_required
def success():
    """
    The page where the user is redirected on successful creation of account.

    :return: renders template success.html
    """
    return render_template("success.html", user=current_user)


@auth.route('/disable2FA')
@login_required
def disable2FA():
    """
    View globally accessible after logging in, used to disable
    two factor authentication.

    :return: renders template disable2FA.html
    """
    try:
        admin = User.query.filter_by(email=current_user.email).first()
        admin.two_FA = False
        db.session.commit()
        flash('2FA disabled', category='error')
        logout()
        return redirect(url_for('auth.login'))
    except:
        flash("Something went wrong, please try again later", category="error")


@auth.route('/femail', methods=['GET', 'POST'])
def femail():
    """
    FORGOT PASSWORD FUNCTIONALITY:
    It is implemented using the following three Views:
    I] femail (forgot-email): Here the user has to enter their registered email address.
    This view is only accessible through /login and associated pages. If this page is
    called, an OTP is generated i.e FOTP. Now, if the user posts a valid email address,
    They are redirected to /OTPcheck (line 377).

    :return: renders template femail.html
    """
    global Femail, FOTP
    referrer = request.referrer
    auth_href = [
        "/login",
        "/login?next=%2Flogout",
        "/login?next=%2Faddblog",
        "/login?next=%2Flogout",
        "/login?next=%2Fsecrets",
        "/login?next=%2Ftwo_FA",
        "/login?next=%2Fsuccess",
        "/login?next=%2Fdisable2FA",
        "/login?next=%2Fdelete",
        "/secrets",
        "/femail"
    ]
    if referrer:
        if referrer[21:] in auth_href:
            if request.method == 'GET':
                FOTP = rn_jesus.return_random(otp_len=6)
            if request.method == 'POST':
                Femail = request.form['Remail']
                admin = User.query.filter_by(email=Femail).first()
                if admin:
                    return redirect(url_for('auth.OTPCheck'))
                else:
                    flash("No such user exists!", category='error')
        else:
            abort(403)
    else:
        abort(403)
    return render_template("femail.html")


@auth.route('/OTPCheck', methods=['GET', 'POST'])
def OTPCheck():
    """
    II] OTPCheck: Referable only from /femail. When this page is called, an OTP
    is emailed to the previously entered email address, now, If the user POSTS
    the correct OTP, they are redirected to /passreset (line 410), where they will be allowed
    to reset their password.

    :return: renders template OTPCheck.html
    """
    referrer = request.referrer
    auth_href = [
        "/femail",
        "/OTPCheck"
    ]
    if referrer:
        if referrer[21:] in auth_href:
            if request.method == 'GET':
                postman.sendmail(Femail, "Citadel Log-in Authorization", FOTP)
            if request.method == 'POST':
                Fuser_otp = request.form['otp']
                if Fuser_otp == FOTP:
                    return redirect(url_for('auth.passreset'))
                else:
                    flash('Wrong otp', category='error')
        else:
            abort(403)
    else:
        abort(403)
    return render_template("OTPCheck.html")


@auth.route('/passreset', methods=['GET', 'POST'])
def passreset():
    """
    III] passreset: Referable only from /OTPCheck. Here the user POSTS a new password,
    if the user role wasn't admin, their account is updated normally, accounts with admin
    roles will updated but with role method overridden. After the updating, the user is
    logged in with the aforementioned protocols (see create() and otp()).

    :return: renders template passreset.html
    """
    referrer = request.referrer
    auth_href = [
        "/OTPCheck",
        "/passreset"
    ]
    if referrer:
        if referrer[21:] in auth_href:
            if request.method == 'POST':
                Cpassword = request.form['pass']
                cpassword = request.form['cpass']
                if Cpassword == cpassword:
                    Duser = User.query.filter_by(email=Femail).first()
                    Duser.password = password_police.generate_password_hash(cpassword, method='argon2id')
                    db.session.commit()
                    flash('Password changed successfully!', category='success')
                    return redirect(url_for('auth.home'))
                else:
                    flash("The passwords don't match", category='error')
        else:
            abort(403)
    else:
        abort(403)

    return render_template("passreset.html", user=current_user)


@auth.route('/delete', methods=['GET', 'POST'])
@login_required
def delete():
    """
    Self explanatory view, deletes the account, all the posts and the comments made by the user.
    Users with admin role don't have an option to their delete account,
    it has to be done manually from database terminal (for security purposes).

    :return: renders template delete.html
    """
    if request.method == 'POST' and current_user.role != "admin":
        demail = current_user.email
        Post.query.filter_by(user_id=current_user.id).delete()
        Comment.query.filter_by(user_id=current_user.id).delete()
        User.query.filter_by(email=current_user.email).delete()
        db.session.commit()
        logout_user()
        flash(f"account {demail} deleted!", category='error')
        return redirect(url_for('auth.home'))
    return render_template('delete.html', user=current_user)
